
/** DONT EDIT THIS FILE **/
/* This file is automatically generated.
  It is not intended for manual editing  */

use crate::simulator::Simulator;
use crate::instruction::*;
use crate::instruction::InstFormat::*;
use crate::{main, register};
use crate::register::{Reg};
use crate::cache::CacheOp;
use Instruction::*;

#[derive(Default, Copy, Clone)]
pub struct ExecuteInfo {
    pub exe_cycles: u64,
    pub mem_access: u64,
    pub load_reg: Reg,
    pub reg_read: [Reg; 2],
    pub is_branch: bool,
    pub taken_branch: bool,
}

#[derive(Debug)]
pub enum Instruction {

    LUI    (UOperands),
    AUIPC  (UOperands),
    JAL    (JOperands),
    JALR   (IOperands),
    BEQ    (BOperands),
    BNE    (BOperands),
    BLT    (BOperands),
    BGE    (BOperands),
    BLTU   (BOperands),
    BGEU   (BOperands),
    LB     (IOperands),
    LH     (IOperands),
    LW     (IOperands),
    LBU    (IOperands),
    LHU    (IOperands),
    SB     (SOperands),
    SH     (SOperands),
    SW     (SOperands),
    ADDI   (IOperands),
    SLTI   (IOperands),
    SLTIU  (IOperands),
    XORI   (IOperands),
    ORI    (IOperands),
    ANDI   (IOperands),
    SLLI   (IOperands),
    SRLI   (IOperands),
    SRAI   (IOperands),
    ADD    (ROperands),
    SUB    (ROperands),
    SLL    (ROperands),
    SLT    (ROperands),
    SLTU   (ROperands),
    XOR    (ROperands),
    SRL    (ROperands),
    SRA    (ROperands),
    OR     (ROperands),
    AND    (ROperands),
    LWU    (IOperands),
    LD     (IOperands),
    SD     (SOperands),
    ADDIW  (IOperands),
    SLLIW  (IOperands),
    SRLIW  (IOperands),
    SRAIW  (IOperands),
    ADDW   (ROperands),
    SUBW   (ROperands),
    SLLW   (ROperands),
    SRLW   (ROperands),
    SRAW   (ROperands),
    MUL    (ROperands),
    MULH   (ROperands),
    MULHSU (ROperands),
    MULHU  (ROperands),
    DIV    (ROperands),
    DIVU   (ROperands),
    REM    (ROperands),
    REMU   (ROperands),
    MULW   (ROperands),
    DIVW   (ROperands),
    DIVUW  (ROperands),
    REMW   (ROperands),
    REMUW  (ROperands),

}

pub(crate) fn execute(sim: &mut Simulator, inst: Instruction) -> ExecuteInfo {
    let r = &mut sim.regs;
    let m = &mut sim.memory;
    let pc = &mut sim.pc;
    let mut exe_cycles = 1;
    let mut access = 0;
    let mut load_reg = Default::default();
    let mut reg_read: [Reg; 2] = Default::default();
    let mut is_branch = false;
    let mut taken_branch = false;
    let mut access_op = CacheOp::Read;
    match inst {

        LUI(UOperands{imm, rd}) => {
            r.set(rd, imm);
            *pc += 4;
            exe_cycles = 1;
        },
        AUIPC(UOperands{imm, rd}) => {
            r.set(rd, *pc + imm);
            *pc += 4;
            exe_cycles = 1;
        },
        JAL(JOperands{imm, rd}) => {
            let t = *pc + 4; *pc += imm; r.set(rd, t);;
            ;
            exe_cycles = 1;
        },
        JALR(IOperands{imm, rs1, rd}) => {
            let t = *pc + 4; *pc = (r.get(rs1) + imm) & !1; r.set(rd, t);
            ;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        BEQ(BOperands{imm, rs2, rs1}) => {
            is_branch = true; taken_branch = r.get(rs1) == r.get(rs2);
            if taken_branch { *pc += imm } else {*pc += 4};
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        BNE(BOperands{imm, rs2, rs1}) => {
            is_branch = true; taken_branch = r.get(rs1) != r.get(rs2);
            if taken_branch { *pc += imm } else {*pc += 4};
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        BLT(BOperands{imm, rs2, rs1}) => {
            is_branch = true; taken_branch = (r.get(rs1) as i64) < (r.get(rs2) as i64);
            if taken_branch { *pc += imm } else {*pc += 4};
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        BGE(BOperands{imm, rs2, rs1}) => {
            is_branch = true; taken_branch = r.get(rs1) as i64 >= r.get(rs2) as i64;
            if taken_branch { *pc += imm } else {*pc += 4};
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        BLTU(BOperands{imm, rs2, rs1}) => {
            is_branch = true; taken_branch = r.get(rs1) < r.get(rs2);
            if taken_branch { *pc += imm } else {*pc += 4};
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        BGEU(BOperands{imm, rs2, rs1}) => {
            is_branch = true; taken_branch = r.get(rs1) >= r.get(rs2);
            if taken_branch { *pc += imm } else {*pc += 4};
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        LB(IOperands{imm, rs1, rd}) => {
            access = r.get(rs1) + imm; r.set(rd, m.load_u8(access) as i8 as u64);
            *pc += 4; load_reg = rd;
            exe_cycles = 1;
            access_op = CacheOp::Read;
            reg_read[0] = rs1;
        },
        LH(IOperands{imm, rs1, rd}) => {
            access = r.get(rs1) + imm; r.set(rd, m.load_u16(access) as i16 as u64);
            *pc += 4; load_reg = rd;
            exe_cycles = 1;
            access_op = CacheOp::Read;
            reg_read[0] = rs1;
        },
        LW(IOperands{imm, rs1, rd}) => {
            access = r.get(rs1) + imm; r.set(rd, m.load_u32(access) as i32 as u64);
            *pc += 4; load_reg = rd;
            exe_cycles = 1;
            access_op = CacheOp::Read;
            reg_read[0] = rs1;
        },
        LBU(IOperands{imm, rs1, rd}) => {
            access = r.get(rs1) + imm; r.set(rd, m.load_u8(access) as u64);
            *pc += 4; load_reg = rd;
            exe_cycles = 1;
            access_op = CacheOp::Read;
            reg_read[0] = rs1;
        },
        LHU(IOperands{imm, rs1, rd}) => {
            access = r.get(rs1) + imm; r.set(rd, m.load_u16(access) as u64);
            *pc += 4; load_reg = rd;
            exe_cycles = 1;
            access_op = CacheOp::Read;
            reg_read[0] = rs1;
        },
        SB(SOperands{imm, rs2, rs1}) => {
            access = r.get(rs1) + imm; m.store_u8(access, r.get(rs2) as u8);
            *pc += 4;
            exe_cycles = 1;
            access_op = CacheOp::Write;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SH(SOperands{imm, rs2, rs1}) => {
            access = r.get(rs1) + imm; m.store_u16(access, r.get(rs2) as u16);
            *pc += 4;
            exe_cycles = 1;
            access_op = CacheOp::Write;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SW(SOperands{imm, rs2, rs1}) => {
            access = r.get(rs1) + imm; m.store_u32(access, r.get(rs2) as u32);
            *pc += 4;
            exe_cycles = 1;
            access_op = CacheOp::Write;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        ADDI(IOperands{imm, rs1, rd}) => {
            r.set(rd, r.get(rs1) + imm);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        SLTI(IOperands{imm, rs1, rd}) => {
            r.set(rd, if (r.get(rs1) as i64) < (imm as i64) {1} else {0});
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        SLTIU(IOperands{imm, rs1, rd}) => {
            r.set(rd, if r.get(rs1) < imm {1} else {0});
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        XORI(IOperands{imm, rs1, rd}) => {
            r.set(rd, r.get(rs1) ^ imm);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        ORI(IOperands{imm, rs1, rd}) => {
            r.set(rd, r.get(rs1) | imm);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        ANDI(IOperands{imm, rs1, rd}) => {
            r.set(rd, r.get(rs1) & imm);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        SLLI(IOperands{imm, rs1, rd}) => {
            r.set(rd, r.get(rs1) << (imm & 0b111111));
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        SRLI(IOperands{imm, rs1, rd}) => {
            r.set(rd, r.get(rs1) >> (imm & 0b111111));
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        SRAI(IOperands{imm, rs1, rd}) => {
            r.set(rd, ((r.get(rs1) as i64) >> (imm as i64 & 0b111111)) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        ADD(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) + r.get(rs2));
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SUB(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) - r.get(rs2));
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SLL(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) << (r.get(rs2) & 0b111111));
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SLT(ROperands{rs2, rs1, rd}) => {
            r.set(rd, if (r.get(rs1) as i64) < (r.get(rs2) as i64) {1} else {0});
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SLTU(ROperands{rs2, rs1, rd}) => {
            r.set(rd, if r.get(rs1) < r.get(rs2) {1} else {0});
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        XOR(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) ^ r.get(rs2));
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SRL(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) >> (r.get(rs2) & 0b111111));
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SRA(ROperands{rs2, rs1, rd}) => {
            r.set(rd, ((r.get(rs1) as i64) >> (r.get(rs2) as i64 & 0b111111)) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        OR(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) | r.get(rs2));
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        AND(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) & r.get(rs2));
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        LWU(IOperands{imm, rs1, rd}) => {
            access = r.get(rs1) + imm; r.set(rd, m.load_u32(access) as i32 as u64);
            *pc += 4; load_reg = rd;
            exe_cycles = 1;
            access_op = CacheOp::Read;
            reg_read[0] = rs1;
        },
        LD(IOperands{imm, rs1, rd}) => {
            access = r.get(rs1) + imm; r.set(rd, m.load_u64(access));
            *pc += 4; load_reg = rd;
            exe_cycles = 1;
            access_op = CacheOp::Read;
            reg_read[0] = rs1;
        },
        SD(SOperands{imm, rs2, rs1}) => {
            access = r.get(rs1) + imm; m.store_u64(access, r.get(rs2));
            *pc += 4;
            exe_cycles = 1;
            access_op = CacheOp::Write;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        ADDIW(IOperands{imm, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as i32 + imm as i32) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        SLLIW(IOperands{imm, rs1, rd}) => {
            r.set(rd, ((r.get(rs1) as i32) << (imm as i32 & 0b011111)) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        SRLIW(IOperands{imm, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as i32 >> (imm as i32 & 0b011111)) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        SRAIW(IOperands{imm, rs1, rd}) => {
            r.set(rd, ((r.get(rs1) as i64) >> (imm as i64 & 0b111111)) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs1;
        },
        ADDW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as i32 + r.get(rs2) as i32) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SUBW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as i32 - r.get(rs2) as i32) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SLLW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, ((r.get(rs1) as i32) << (r.get(rs2) as i32 & 0b11111)) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SRLW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as u32 >> (r.get(rs2) as u32 & 0b11111)) as i32 as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        SRAW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as i32 >> (r.get(rs2) as i32 & 0b11111)) as u64);
            *pc += 4;
            exe_cycles = 1;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        MUL(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) * r.get(rs2));
            *pc += 4;
            exe_cycles = 5;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        MULH(ROperands{rs2, rs1, rd}) => {
            r.set(rd, ((r.get(rs1) as i128 * r.get(rs2) as i128) >> 64) as u64);
            *pc += 4;
            exe_cycles = 5;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        MULHSU(ROperands{rs2, rs1, rd}) => {
            r.set(rd, ((r.get(rs1) as i128 as u128 * r.get(rs2) as u128) >> 64) as u64);
            *pc += 4;
            exe_cycles = 5;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        MULHU(ROperands{rs2, rs1, rd}) => {
            r.set(rd, ((r.get(rs1) as u128 * r.get(rs2) as u128) >> 64) as u64);
            *pc += 4;
            exe_cycles = 5;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        DIV(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as i64 / r.get(rs2) as i64) as u64);
            *pc += 4;
            exe_cycles = 20;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        DIVU(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) / r.get(rs2));
            *pc += 4;
            exe_cycles = 20;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        REM(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as i64 % r.get(rs2) as i64) as u64);
            *pc += 4;
            exe_cycles = 20;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        REMU(ROperands{rs2, rs1, rd}) => {
            r.set(rd, r.get(rs1) % r.get(rs2));
            *pc += 4;
            exe_cycles = 20;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        MULW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as u32 * r.get(rs2) as u32) as i32 as u64);
            *pc += 4;
            exe_cycles = 5;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        DIVW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as i32 / r.get(rs2) as i32) as u64);
            *pc += 4;
            exe_cycles = 20;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        DIVUW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as u32 / r.get(rs2) as u32) as i32 as u64);
            *pc += 4;
            exe_cycles = 20;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        REMW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as i32 % r.get(rs2) as i32) as u64);
            *pc += 4;
            exe_cycles = 20;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },
        REMUW(ROperands{rs2, rs1, rd}) => {
            r.set(rd, (r.get(rs1) as u32 % r.get(rs2) as u32) as i32 as u64);
            *pc += 4;
            exe_cycles = 20;
            reg_read[0] = rs2;
            reg_read[1] = rs1;
        },

    };
    let mem_access = if access == 0 { 0 } else { sim.cache.access(access, access_op) };
    ExecuteInfo {
        exe_cycles,
        mem_access,
        load_reg,
        reg_read,
        is_branch,
        taken_branch,
    }
}

pub(crate) fn matching<T>(code: T) -> Instruction
    where T: InstrMatch {

    if code.is_match(UFormat(0b_0110111)) { return LUI(code.decode_U()) }
    if code.is_match(UFormat(0b_0010111)) { return AUIPC(code.decode_U()) }
    if code.is_match(JFormat(0b_1101111)) { return JAL(code.decode_J()) }
    if code.is_match(IFormat(0b_000,0b_1100111)) { return JALR(code.decode_I()) }
    if code.is_match(BFormat(0b_000,0b_1100011)) { return BEQ(code.decode_B()) }
    if code.is_match(BFormat(0b_001,0b_1100011)) { return BNE(code.decode_B()) }
    if code.is_match(BFormat(0b_100,0b_1100011)) { return BLT(code.decode_B()) }
    if code.is_match(BFormat(0b_101,0b_1100011)) { return BGE(code.decode_B()) }
    if code.is_match(BFormat(0b_110,0b_1100011)) { return BLTU(code.decode_B()) }
    if code.is_match(BFormat(0b_111,0b_1100011)) { return BGEU(code.decode_B()) }
    if code.is_match(IFormat(0b_000,0b_0000011)) { return LB(code.decode_I()) }
    if code.is_match(IFormat(0b_001,0b_0000011)) { return LH(code.decode_I()) }
    if code.is_match(IFormat(0b_010,0b_0000011)) { return LW(code.decode_I()) }
    if code.is_match(IFormat(0b_100,0b_0000011)) { return LBU(code.decode_I()) }
    if code.is_match(IFormat(0b_101,0b_0000011)) { return LHU(code.decode_I()) }
    if code.is_match(SFormat(0b_000,0b_0100011)) { return SB(code.decode_S()) }
    if code.is_match(SFormat(0b_001,0b_0100011)) { return SH(code.decode_S()) }
    if code.is_match(SFormat(0b_010,0b_0100011)) { return SW(code.decode_S()) }
    if code.is_match(IFormat(0b_000,0b_0010011)) { return ADDI(code.decode_I()) }
    if code.is_match(IFormat(0b_010,0b_0010011)) { return SLTI(code.decode_I()) }
    if code.is_match(IFormat(0b_011,0b_0010011)) { return SLTIU(code.decode_I()) }
    if code.is_match(IFormat(0b_100,0b_0010011)) { return XORI(code.decode_I()) }
    if code.is_match(IFormat(0b_110,0b_0010011)) { return ORI(code.decode_I()) }
    if code.is_match(IFormat(0b_111,0b_0010011)) { return ANDI(code.decode_I()) }
    if code.is_match(IFormat(0b_001,0b_0010011)) { return SLLI(code.decode_I()) }
    if code.is_match(IFormat(0b_101,0b_0010011)) { return SRLI(code.decode_I()) }
    if code.is_match(IFormat(0b_101,0b_0010011)) { return SRAI(code.decode_I()) }
    if code.is_match(RFormat(0b_0000000,0b_000,0b_0110011)) { return ADD(code.decode_R()) }
    if code.is_match(RFormat(0b_0100000,0b_000,0b_0110011)) { return SUB(code.decode_R()) }
    if code.is_match(RFormat(0b_0000000,0b_001,0b_0110011)) { return SLL(code.decode_R()) }
    if code.is_match(RFormat(0b_0000000,0b_010,0b_0110011)) { return SLT(code.decode_R()) }
    if code.is_match(RFormat(0b_0000000,0b_011,0b_0110011)) { return SLTU(code.decode_R()) }
    if code.is_match(RFormat(0b_0000000,0b_100,0b_0110011)) { return XOR(code.decode_R()) }
    if code.is_match(RFormat(0b_0000000,0b_101,0b_0110011)) { return SRL(code.decode_R()) }
    if code.is_match(RFormat(0b_0100000,0b_101,0b_0110011)) { return SRA(code.decode_R()) }
    if code.is_match(RFormat(0b_0000000,0b_110,0b_0110011)) { return OR(code.decode_R()) }
    if code.is_match(RFormat(0b_0000000,0b_111,0b_0110011)) { return AND(code.decode_R()) }
    if code.is_match(IFormat(0b_110,0b_0000011)) { return LWU(code.decode_I()) }
    if code.is_match(IFormat(0b_011,0b_0000011)) { return LD(code.decode_I()) }
    if code.is_match(SFormat(0b_011,0b_0100011)) { return SD(code.decode_S()) }
    if code.is_match(IFormat(0b_000,0b_0011011)) { return ADDIW(code.decode_I()) }
    if code.is_match(IFormat(0b_001,0b_0011011)) { return SLLIW(code.decode_I()) }
    if code.is_match(IFormat(0b_101,0b_0011011)) { return SRLIW(code.decode_I()) }
    if code.is_match(IFormat(0b_101,0b_0011011)) { return SRAIW(code.decode_I()) }
    if code.is_match(RFormat(0b_0000000,0b_000,0b_0111011)) { return ADDW(code.decode_R()) }
    if code.is_match(RFormat(0b_0100000,0b_000,0b_0111011)) { return SUBW(code.decode_R()) }
    if code.is_match(RFormat(0b_0000000,0b_001,0b_0111011)) { return SLLW(code.decode_R()) }
    if code.is_match(RFormat(0b_0000000,0b_101,0b_0111011)) { return SRLW(code.decode_R()) }
    if code.is_match(RFormat(0b_0100000,0b_101,0b_0111011)) { return SRAW(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_000,0b_0110011)) { return MUL(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_001,0b_0110011)) { return MULH(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_010,0b_0110011)) { return MULHSU(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_011,0b_0110011)) { return MULHU(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_100,0b_0110011)) { return DIV(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_101,0b_0110011)) { return DIVU(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_110,0b_0110011)) { return REM(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_111,0b_0110011)) { return REMU(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_000,0b_0111011)) { return MULW(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_100,0b_0111011)) { return DIVW(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_101,0b_0111011)) { return DIVUW(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_110,0b_0111011)) { return REMW(code.decode_R()) }
    if code.is_match(RFormat(0b_0000001,0b_111,0b_0111011)) { return REMUW(code.decode_R()) }

    panic!("unknown instruction");
}

