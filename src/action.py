import csv


print(r"""
/** DONT EDIT THIS FILE **/
/* This file is automatically generated.
  It is not intended for manual editing  */

use crate::simulator::Simulator;
use crate::instruction::*;
use crate::instruction::InstFormat::*;
use crate::{main, register};
use crate::register::{Reg};
use Instruction::*;

#[derive(Default, Copy, Clone)]
pub struct ExecuteInfo {
    pub exe_cycles: u64,
    pub mem_access: u64,
    pub load_reg: Reg,
    pub reg_read: [Reg; 2],
    pub is_branch: bool,
    pub taken_branch: bool,
}

#[derive(Debug)]
pub enum Instruction {
""")

with open('action.csv', 'r') as csvfile:
	reader = csv.DictReader(csvfile, delimiter=',', quotechar='"')
	for i in reader:
		print('    {:<7}({}Operands),'.format(i["Name"], i["Type"]))
		

print(r"""
}

pub(crate) fn execute(sim: &mut Simulator, inst: Instruction) -> ExecuteInfo {
    let r = &mut sim.regs;
    let m = &mut sim.memory;
    let pc = &mut sim.pc;
    let mut exe_cycles = 1;
    let mut access = 0;
    let mut load_reg = Default::default();
    let mut reg_read: [Reg; 2] = Default::default();
    let mut is_branch = false;
    let mut taken_branch = false;
    match inst {
""")

dict_operands = {
	"R": "rs2, rs1, rd",
	"I": "imm, rs1, rd",
	"S": "imm, rs2, rs1",
	"B": "imm, rs2, rs1",
	"U": "imm, rd",
	"J": "imm, rd",
	"": "",
}

dict_read_reg = {
	"R": "rs2 rs1",
	"I": "rs1",
	"S": "rs2 rs1",
	"B": "rs2 rs1",
	"U": "",
	"J": "",
}

with open('action.csv', 'r') as csvfile:
	reader = csv.DictReader(csvfile, delimiter=',', quotechar='"')
	for i in reader:
		print('        {}({}Operands{{{}}}) => {{'.format(
			i["Name"], i["Type"], dict_operands[i["Type"]]))
		print('            {};'.format(i["Action1"]))
		print('            {};'.format(i["Action2"]))
		print('            exe_cycles = {};'.format(i["Cycles"]))

		read_reg = dict_read_reg[i["Type"]].split()
		for i, reg in enumerate(read_reg):
			print('            reg_read[{}] = {};'.format(i, reg))

		print('        },')

print(r"""
    };
    let mem_access = sim.cache.access(access);
    ExecuteInfo {
        exe_cycles,
        mem_access,
        load_reg,
        reg_read,
        is_branch,
        taken_branch,
    }
}

pub(crate) fn matching<T>(code: T) -> Instruction
    where T: InstrMatch {
""")

dict_t = {
	"R": "Funct7 Funct3 opcode",
	"I": "Funct3 opcode",
	"S": "Funct3 opcode",
	"B": "Funct3 opcode",
	"U": "opcode",
	"J": "opcode",
	"": "",
}

with open('action.csv', 'r') as csvfile:
	reader = csv.DictReader(csvfile, delimiter=',', quotechar='"')
	for i in reader:
		t = i["Type"]
		s = ','.join(map(lambda x: "0b_" + i[x], dict_t[t].split()))

		print('    if code.is_match({}Format({})) {{ return {}(code.decode_{}()) }}'
			.format(t, s, i["Name"], t))

print(r"""
    panic!("unknown instruction");
}
""")

